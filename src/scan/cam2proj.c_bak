/*
 * This file is part of Lighttwist.
 * 
 * @Copyright 2004-2008 Université de Montréal, Laboratoire Vision3D
 *   Sébastien Roy (roys@iro.umontreal.ca)
 *   Vincent Chapdelaine-Couture (chapdelv@iro.umontreal.ca)
 *   Louis Bouchard (lwi.bouchard@gmail.com)
 *   Jean-Philippe Tardif
 *   Patrick Holloway
 *   Nicolas Martin
 *   Vlad Lazar
 *   Jamil Draréni 
 *   Marc-Antoine Drouin
 * @Copyright 2005-2007 Société des arts technologiques
 *
 * Lighttwist is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Lighttwist is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Lighttwist.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * recon.c  -  This program will make a deformation map based on
 *               the structured light images received in input.
 *               Only grayscale format supported for images.
 */

#include "cam2proj.h"

#include <utils/graycode.h>
#include <utils/crop.h>

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <float.h>

int crop_active;

// pour inverser...
//#define FLIP_HORIZ
//#define FLIP_VERT

// le rayon maximum dans le projecteur pour un triangle dans la camera
// Cette constante pourrait avoir a changer selon la resolution du projecteur... :-(
#define MAXIMUM_R	40.0

// combien de % des points avec la plus grande variation on conserve pour les stats d'ambient
#define PERCENT_HIGHEST_TRANGE	30

typedef struct
{
    unsigned long mx;	// mask x
    unsigned long my;	// mask y
    int pos,neg;		// number of positive and negative images
} pattern;

int NB_MAX_ITER;

// loading variables
imgu **Tselect; // pattern images (1 image per pattern)
imgu *Trange; // contrast of the images for the whole sequence (for each pixel)
int g_img_size_x, g_img_size_y; // size of pattern images (from the camera)
int g_type;  // Type of reconstruction
float g_mrf_beta; // Markovian beta
int g_range_min; // minimum range

// binary code for each pattern
pattern *pat;

// to save
char *g_out_prefix; // Prefix for the output data
int g_cam; //Number of the camera

// codes (created by recode_xy)
// codes are position * SUBPIX (=3 bits)
int *xcode,*ycode; // final code of the pixel
int *x_bestcode,*y_bestcode; // best cost code
int *xconf,*yconf; // Confidence. For each bit of the code, 1=can be trusted, 0=cannot be trusted
int *xyvalid; // number of valid bits in x and y

int *xy_changed_code; //flag to know if the code has changed

int nbbits_x;
int nbbits_y;

double randNumber()
{
    double rd;
#ifdef WIN32
    rd=(double)(rand())/RAND_MAX;
#else
    rd=drand48();
#endif
    return rd;
}

void code_to_img(int* data, int xsize, int ysize, char* name, int nb_bit, int offset)
{
    int i;
    imgu *i_new;

    i_new=NULL;
    int mask = pow(2, nb_bit) -1;
    imguAllocate(&i_new,xsize, ysize, 1);

    for(i=0;i< i_new->xs * i_new->ys ;i++)
    {
        i_new->data[i]=(unsigned char) ( (data[i] >> offset) & mask  ) << (8 - nb_bit);
    }

    imguSave(i_new,name,FAST_COMPRESSION,SAVE_8_BITS_LOW);
    imguFree(&i_new);

    LT_PRINTF ("Saved %s\n", name);
}

// assume that images 0..nb match to pattern pat[]
void recover_xy(int confidence_min,int nb_pattern)
{
    int i,p,ipos,ineg,d,v;
    int m;
    xcode=(int *)malloc( g_img_size_x * g_img_size_y *sizeof(int));
    ycode=(int *)malloc( g_img_size_x * g_img_size_y *sizeof(int));
    xconf=(int *)malloc( g_img_size_x * g_img_size_y *sizeof(int));
    yconf=(int *)malloc( g_img_size_x * g_img_size_y *sizeof(int));
    xyvalid=(int *)malloc( g_img_size_x * g_img_size_y *sizeof(int));

    // initialize to 0
    for(i=0;i< g_img_size_x * g_img_size_y ;i++)
    {
        xcode[i] = 0;
        ycode[i] = 0;
        xconf[i] = 0;
        yconf[i] = 0;
        xyvalid[i]=0;
    }

    // for each pixel
    for(i=0;i< g_img_size_x * g_img_size_y ;i++)
    {
        // for each code
        // pat[0..9]   ==> horizontal
        // pat[10..19] ==> vertical
        for(p=0;p<nb_pattern/2;p++)
        {
            ipos=Tselect[pat[p].pos]->data[i];
            ineg=Tselect[pat[p].neg]->data[i];

	    if( ipos>=ineg )
	    {
		xcode[i]|=pat[p].mx;
		ycode[i]|=pat[p].my;
	    }


            d=ipos-ineg;
            if( d<0 )
                d=-d;

            v=d*100/(Trange->data[i]+1);

            // check if the pixel is clearly defined (compare with Trange(the maximum difference for this pixel))
            if( v>=confidence_min && Trange->data[i]> g_range_min)
            {
                xconf[i]|=pat[p].mx;
                yconf[i]|=pat[p].my;
            }
        }


        // we shift the code for sub-pixel
        // all new bits are set to 0 and 0 confidence
        // warning, it's graycode!
        xcode[i]=encode(decode(xcode[i],nbbits_x)<<SUBPIX);
        ycode[i]=encode(decode(ycode[i],nbbits_y)<<SUBPIX);
        xconf[i]=xconf[i]<<SUBPIX;
        yconf[i]=yconf[i]<<SUBPIX;
    }


    // calculate validity for each pixel -> number of trusted bits
    for(i=0;i< g_img_size_x * g_img_size_y ;i++)
    {
        for(m=getpowerof2(nbbits_x)/2<<SUBPIX;m;m>>=1)
        {
            if( xconf[i]&m ) xyvalid[i]++;
        }
        for(m=getpowerof2(nbbits_y)/2<<SUBPIX;m;m>>=1)
        {
            if( yconf[i]&m ) xyvalid[i]++;
        }
    }

    ////// filtre les xyvalide
    // un xyvalid > VALIDITY_THRESHOLD
    // entoure de non valides sera elimine...
    {
        int x,y,xx,yy,dx,dy,k;
        for(y=0;y<g_img_size_y;y++)
            for(x=0;x<g_img_size_x;x++) {
                if( xyvalid[y*g_img_size_x+x]<VALIDITY_THRESHOLD ) continue;
                k=4;
                for(dy=-1;dy<=1;dy+=2)
                    for(dx=-1;dx<=1;dx+=2) {
                        xx=x+dx;
                        yy=y+dy;
                        if( xx<0 || xx>=g_img_size_x || yy<0 || yy>=g_img_size_y) continue;
                        if( xyvalid[yy*g_img_size_x+xx]<VALIDITY_THRESHOLD ) k--;
                    }
                if( k==0 ) xyvalid[y*g_img_size_x+x]=0;
            }
    }

    // save codes
    // Note: xcode is a array of int. Each cell of the array contains a number that range from 0 to 1023.
    //       To save it in image, we must divide it in 2 part - hi and low (1023 cannot fit into a image of zsize=1)
    {
        char buf[200];
        imgu *hi,*low;
        hi=NULL;
        low=NULL;
        imguAllocate(&hi, g_img_size_x , g_img_size_y ,1);
        imguAllocate(&low, g_img_size_x , g_img_size_y ,1);
        for(i=0;i< g_img_size_x * g_img_size_y ;i++)
        {
            hi->data[i]=decode(xcode[i],nbbits_x+SUBPIX)>>(nbbits_x-8+SUBPIX);
            low->data[i]=decode(xcode[i],nbbits_x+SUBPIX)&0xff;
        }
        sprintf(buf,"%sxcode_hi_%02d.png",g_out_prefix,g_cam);
        imguSave(hi,buf,FAST_COMPRESSION,SAVE_8_BITS_LOW);
        sprintf(buf,"%sxcode_low_%02d.png",g_out_prefix,g_cam);
        imguSave(low,buf,FAST_COMPRESSION,SAVE_8_BITS_LOW);
        for(i=0;i< g_img_size_x * g_img_size_y ;i++)
        {
            hi->data[i]=xconf[i]>>(nbbits_x-8+SUBPIX);
            low->data[i]=xconf[i]&0xff;
        }
        sprintf(buf,"%sxconf_hi_%02d.png",g_out_prefix,g_cam);
        imguSave(hi,buf,FAST_COMPRESSION,SAVE_8_BITS_LOW);
        sprintf(buf,"%sxconf_low_%02d.png",g_out_prefix,g_cam);
        imguSave(low,buf,FAST_COMPRESSION,SAVE_8_BITS_LOW);

        for(i=0;i< g_img_size_x * g_img_size_y ;i++)
        {
            hi->data[i]=decode(ycode[i],nbbits_y+SUBPIX)>>(nbbits_y-8+SUBPIX);
            low->data[i]=decode(ycode[i],nbbits_y+SUBPIX)&0xff;
        }
        sprintf(buf,"%sycode_hi_%02d.png",g_out_prefix,g_cam);
        imguSave(hi,buf,FAST_COMPRESSION,SAVE_8_BITS_LOW);
        sprintf(buf,"%sycode_low_%02d.png",g_out_prefix,g_cam);
        imguSave(low,buf,FAST_COMPRESSION,SAVE_8_BITS_LOW);
        for(i=0;i< g_img_size_x * g_img_size_y ;i++)
        {
            hi->data[i]=yconf[i]>>(nbbits_y-8+SUBPIX);
            low->data[i]=yconf[i]&0xff;
        }
        sprintf(buf,"%syconf_hi_%02d.png",g_out_prefix,g_cam);
        imguSave(hi,buf,FAST_COMPRESSION,SAVE_8_BITS_LOW);
        sprintf(buf,"%syconf_low_%02d.png",g_out_prefix,g_cam);
        imguSave(low,buf,FAST_COMPRESSION,SAVE_8_BITS_LOW);

        for(i=0;i< g_img_size_x * g_img_size_y ;i++) hi->data[i]=xyvalid[i]*10;
        sprintf(buf,"%sxyvalid_%02d.png",g_out_prefix,g_cam);
        LT_PRINTF("saving %s\n",buf);
        imguSave(hi,buf,FAST_COMPRESSION,SAVE_8_BITS_LOW);

        imguFree(&hi);
        imguFree(&low);
    }
}

#define NB_PROB	(PROJ_CODE<<SUBPIX)
#define NB_COST	(PROJ_CODE<<SUBPIX)
#define MAX_WIN	49

#ifdef JP_MRFI

#define HUF_MAX 100000000.

//=====================================================================================
//    Patterns resolution with MRF formulation, we just do 1 pass of ICM

int g_nb_site_changed;
double g_cost_total;
double g_cost_best;

void MrfI_init()
{

    x_bestcode=(int *)malloc( g_img_size_x * g_img_size_y *sizeof(int));
    y_bestcode=(int *)malloc( g_img_size_x * g_img_size_y *sizeof(int));

    g_cost_best = DBL_MAX;

    int i;
    for (i = 0; i < g_img_size_x*g_img_size_y; i++)
    {
        x_bestcode[i] = xcode[i];
        y_bestcode[i] = ycode[i];
    }
}


void MrfI_save_state ()
{
    g_cost_best = g_cost_total;

    int i;
    for (i = 0; i < g_img_size_x*g_img_size_y; i++)
    {
        x_bestcode[i] = xcode[i];
        y_bestcode[i] = ycode[i];
    }
}


// 2 compatibles labels in function of confidence, valid bits must be the same
int MrfI_compatible (int etiq_m, int etiq_n, int conf_n)
{
    if (((etiq_m ^ etiq_n) & conf_n) == 0) // ^ = XOR
        return 1;
    else
        return 0;
}


// Number of different bits between 2 labels in their representation
int MrfI_etiq_dist(int etiq_m, int etiq_n)
{
    int mD = decode_table_x(etiq_m,nbbits_x+SUBPIX);
    int nD = decode_table_y(etiq_n,nbbits_y+SUBPIX);

    return (mD-nD)*(mD-nD);
}


float get_MrfIMatchCont_X(int pos_xy, int code, int conf, int e)
{
    int p = 0, ipos, ineg;
    float d,v;
    float prob = 1.;

    for(p=0;p<10;p++)
    {
        ipos=Tselect[pat[p].pos]->data[pos_xy];
        ineg=Tselect[pat[p].neg]->data[pos_xy];
        d=(float) ipos- (float) ineg;

        if (Trange->data[pos_xy] == 0)
            v = 0.5;
        else
            v=abs(d)/(2.0*Trange->data[pos_xy]) + 0.5;

        if (Trange->data[pos_xy] <= g_range_min)
            v = 0.5;

        if ( (code & (0x1<< (9-p))) != (e & (0x1<< (9-p))))
        {
            v = 1. - v; //inverse because it's the bit we don't keep.
        }

        prob *=v;
    }

    prob = -log (prob); //inverse because it's a cost
    return prob;
}


float get_MrfIMatchCont_Y(int pos_xy, int code, int conf, int e)
{
    int p = 0, ipos, ineg;
    float d,v;
    float prob = 1.;

    for(p=10;p<20;p++)
    {
        ipos=Tselect[pat[p].pos]->data[pos_xy];
        ineg=Tselect[pat[p].neg]->data[pos_xy];
        d=(float) ipos- (float) ineg;

        if (Trange->data[pos_xy] == 0)
            v = 0.5;
        else
            v=abs(d)/(2.*Trange->data[pos_xy]) + 0.5;

        if (Trange->data[pos_xy] <= g_range_min)
            v = 0.5;

        if ( (code & (0x1<< (9-p))) != (e & (0x1<< (9-p))))
        {
            v = 1. - v; //inverse because it's the bit we don't keep.
        }

        prob *=v;
    }

    prob = -log (prob) ; //inverse because it's a cost
    return prob;
}


//Energy function
float MrfI_Up(int etiq_m, int etiq_n, int conf_n, int pos_xy, int dim)
{
    int val;

    val = MrfI_compatible(etiq_m, etiq_n,  conf_n);

    switch (g_type)
    {
        case MARKOV_JP:
            if(val == 1)
                return ((float) MrfI_etiq_dist(etiq_m, etiq_n));
            else
                return HUF_MAX;
            break;

        case MARKOV_SIMPLE:
            if(val == 1)
                return 0;
            else
                return HUF_MAX;
            break;

        case MARKOV_CONT:
            if(val == 1)
            {
                if (dim ==0)
                    return get_MrfIMatchCont_X(pos_xy,etiq_n, conf_n, etiq_m);
                else
                    return get_MrfIMatchCont_Y(pos_xy,etiq_n, conf_n, etiq_m);
            }
            else
                return HUF_MAX;
            break;
    }
    return(0.0);
}


//Smooting function with valid neighbour bits
float MrfI_Ul(int etiq_n, int etiq_v, int conf_v)
{
    //compatibility is not important here
    switch (g_type)
    {
        case MARKOV_SIMPLE:
        case MARKOV_JP:
            return ((float) MrfI_etiq_dist(etiq_n, etiq_v));
            break;

        case MARKOV_CONT:
            return ((float) MrfI_etiq_dist(etiq_n, etiq_v));
            break;
    }
    return 0.0;
}


//Calculate the probability of each label for a pixel
void MrfI_get_cost(float cost[NB_COST],int code,int conf,
        int* voisin_code,int*  voisin_conf,
        int n, int pos_xy,
        int dim) //0 for X, 1 for Y
{
    int i,j;
    for(i=0;i<NB_COST;i++)
    {
        // check if i is a valid code
        // i must be equal to code code (only if conf=1)
        cost[i] = MrfI_Up(i,code, conf, pos_xy, dim);

#ifdef OPTI_MRF
        if(cost[i] == HUF_MAX)
        {
            continue; //We just want compatible codes in the original solution
        }
#endif

        float cost_lissage = 0.;
        int nb_compat = 0;
        float temp;

        for (j = 0; j < n; j++)
        {
            temp = ((float) MrfI_Ul(i, voisin_code[j], voisin_conf[j]));
            cost_lissage+=temp;
            nb_compat++;
        }

        cost[i]+= g_mrf_beta * cost_lissage/ (float) (nb_compat);//moyenne du coup
    }
}


int MrfI_process_window(int* wcode,int* wconf,int n,int code,int conf,int mask,
        int pos_xy, int dim)
{
    int i;
    int newcode;
    float cost[NB_COST]; // contain the probability of x,y (the cost to minimize)
    float best;
    float best_dist;

    for(i=0;i<NB_COST;i++)
        cost[i]=HUF_MAX;

    MrfI_get_cost(cost,code,conf, wcode, wconf, n, pos_xy, dim);

    // find the most probable, keep the current if possible
    // (another solution: take the smallest)
    newcode=code;
    best_dist = best  = HUF_MAX;

    for(i=0;i<NB_COST;i++)
    {
        if(cost[i] >= HUF_MAX)
            continue;

        if( cost[i]<=best )
        {
            if (cost[i] == best) //if equal, takethe nearest to the original code
            {
                if (abs(i - code) < abs(newcode - code))
                {
                    best=cost[i];
                    newcode=i;
                }
            }
            else //automatically keep it
            {
                best=cost[i];
                newcode=i;
            }
        }
    }

    if (best >= HUF_MAX)
        return code;

    g_cost_total += (double) best;

    //get an idea of the modifications
    if (newcode != code)
    {
        g_nb_site_changed+=1;
        xy_changed_code[pos_xy] = 0xFF;

#ifdef VERBOSE_FIX
        LT_PRINTF("oldcode=%4d=",code);
        dump_bin(code,mask);LT_PRINTF("\n");
        LT_PRINTF("newcode=%4d=",newcode);
        dump_bin(newcode,mask);LT_PRINTF("\n");
#endif
    }

    return(newcode);
}


double MrfI_fix_xy(int mask)
{
    int x,y,xx,yy,n;
    int w; // width/height of the window = (1+2w)
    int ws; // =1+2w
    int xwcode[MAX_WIN]; // window data - x (codes)
    int xwconf[MAX_WIN]; // window data - x (confidence)
    int ywcode[MAX_WIN]; // window data - y (codes)
    int ywconf[MAX_WIN]; // window data - y (confidence)
    int newcode;

    g_cost_total = 0.;

    w=1;ws=1+2*w;
    if( ws>MAX_WIN )
    {
        LT_PRINTF("OOM!\n");
        LT_EXIT(0);
    }

    g_nb_site_changed = 0;
    xy_changed_code = (int*) malloc (sizeof (int) *g_img_size_x*g_img_size_y);

    for (x = 0; x < g_img_size_x*g_img_size_y; x++)
        xy_changed_code[x] = 0;

    for(y=w;y< g_img_size_y -w;y++)
    {
        if( y%100==0 )
        {
            LT_PRINTF("\x0d");
            MPRINTF("y=%d",y);
        }

        for(x=w;x< g_img_size_x -w;x++)
        {

            int nx = (int)(randNumber()*(g_img_size_x-2*w)+w+0.5);
            int ny = (int)(randNumber()*(g_img_size_y-2*w)+w+0.5);

            n=0;
            for(yy=ny-w;yy<=ny+w;yy++)
            {
                for(xx=nx-w;xx<=nx+w;xx++)
                {
                    // a pixel is not the neighbour of itself
                    if( xx==x && yy==y )
                        continue;
                    if( xyvalid[yy* g_img_size_x +xx]<VALIDITY_THRESHOLD )
                        continue;

                    xwcode[n]=xcode[yy* g_img_size_x +xx];
                    xwconf[n]=xconf[yy* g_img_size_x +xx];
                    ywcode[n]=ycode[yy* g_img_size_x +xx];
                    ywconf[n]=yconf[yy* g_img_size_x +xx];
                    n++;

                }
            }

#ifdef OPTI_MRF
            if( n<ws)
            {
                continue;
            }
#endif
            newcode=MrfI_process_window(xwcode,xwconf,n,xcode[ny* g_img_size_x +nx],xconf[ny* g_img_size_x +nx],
                    mask, ny* g_img_size_x+ nx, 0);
            xcode[ny* g_img_size_x +nx]=newcode;
            newcode=MrfI_process_window(ywcode,ywconf,n,ycode[ny* g_img_size_x +nx],yconf[ny* g_img_size_x +nx],
                    mask, ny* g_img_size_x+ nx, 1);
            ycode[ny* g_img_size_x +nx]=newcode;
        }
    }

    char buf[200]; sprintf(buf, "changed.png");
    //code_to_img(xy_changed_code, g_img_size_x, g_img_size_y, buf, 8, 0);
    MPRINTF ("Changed Code %d\n", g_nb_site_changed);
    free(xy_changed_code);

#ifdef MRF_COOL_DOWN
    //#warning MRF_COOL_DOWN
    g_mrf_beta *= MRF_COOL_DOWN;
#endif

    MPRINTF ("Cost: %f\n", g_cost_total);

    if (g_cost_total < g_cost_best)
    {
        MPRINTF ("got better result...saving\n");
        MrfI_save_state ();
        return 1;
    }
    else
    {
        return -1;
    }
}

#endif //#ifdef JP_MRFI


// integer mean...but with SUBPIX. Sufficient.
// the problem is: how to obtain the good mean when the points
// of the window are not equally distributed around the middle?
// This is especially the case on the border of the images.
// It's an absolute neccesity to have a symetric window (in the 2 ways).
void mean(int w)
{
    int n,xsum,ysum,vsum;
    int x,y,xx,yy,i,ii,iii,xxx,yyy;
    int *xc,*yc,*val;

    MPRINTF("--- mean on %dx%d, sz=%d\n",1+w*2,1+w*2,(1+w*2)*(1+w*2));
    xc=(int *)malloc( g_img_size_x * g_img_size_y *sizeof(int));
    yc=(int *)malloc( g_img_size_x * g_img_size_y *sizeof(int));
    val=(int *)malloc( g_img_size_x * g_img_size_y *sizeof(int));

    for(y=0;y< g_img_size_y ;y++)
    {
        for(x=0;x< g_img_size_x ;x++)
        {
            i=y* g_img_size_x +x;
            n=0;
            xsum=ysum=vsum=0;

            // symetric scan
            // keep only if they are 2 useable points
#ifdef SYMETRIC
            for(yy=y-w;yy<=y;yy++)
            {
                yyy=2*y-yy;
                if( yy<0 || yy>= g_img_size_y  )
                    continue;
                if( yyy<0 || yyy>= g_img_size_y  )
                    continue;

                for(xx=x-w;xx<=x;xx++)
                {
                    xxx=2*x-xx;
                    if( xx<0 || xx>= g_img_size_x  )
                        continue;
                    if( xxx<0 || xxx>= g_img_size_x  )
                        continue;
                    ii=yy* g_img_size_x +xx;
                    iii=yyy* g_img_size_x +xxx;
                    if( xyvalid[ii]<VALIDITY_THRESHOLD || xyvalid[iii]<VALIDITY_THRESHOLD )
                        continue;

                    if( ii!=iii )
                    {
                        xsum+=xcode[ii]+xcode[iii];
                        ysum+=ycode[ii]+ycode[iii];
                        vsum+=xyvalid[ii]+xyvalid[iii];
                        n+=2;
                    }
                    else
                    {
                        xsum+=xcode[ii];
                        ysum+=ycode[ii];
                        vsum+=xyvalid[ii];
                        n++;
                    }
                }
            }
#else
            for(yy=y-w;yy<=y+w;yy++)
            {
                if( yy<0 || yy>= g_img_size_y  )
                    continue;
                for(xx=x-w;xx<=x+w;xx++)
                {
                    if( xx<0 || xx>= g_img_size_x  )
                        continue;
                    ii=yy* g_img_size_x +xx;
                    if( xyvalid[ii]<VALIDITY_THRESHOLD )
                        continue;
                    xsum+=xcode[ii];
                    ysum+=ycode[ii];
                    vsum+=xyvalid[ii];
                    n++;
                }
            }
#endif
            if( n==0 )
            {
                xc[i]=xcode[i];
                yc[i]=ycode[i];
                val[i]=xyvalid[i];
                continue;
            }

            // codes are sub-pixel now
            xc[i]=((xsum*2)+n)/(n*2);
            yc[i]=((ysum*2)+n)/(n*2);
            val[i]=(vsum*2+n)/(n*2);
        }
    }

    // copy!
    for(i=0;i< g_img_size_x * g_img_size_y ;i++)
    {
        xcode[i]=xc[i];
        ycode[i]=yc[i];
    }

    free(xc);
    free(yc);
    free(val);
}


// overwrite the Gray code by the decoded binary code
void kill_gray(void)
{
    int i;
    LT_PRINTF("kill gray codes...\n");
    for(i=0;i< g_img_size_x * g_img_size_y ;i++)
    {
        xcode[i]=decode(xcode[i],nbbits_x+SUBPIX);
        ycode[i]=decode(ycode[i],nbbits_y+SUBPIX);
    }
    LT_PRINTF("kill gray codes.. done\n");
}


// return 0 if ok, -1 si inversed triangle
int check_triangle(double x1,double y1,double x2,double y2,double x3,double y3)
{
    double z;

    z= -(x2*y1) + x3*y1 + x1*y2 - x3*y2 - x1*y3 + x2*y3;
    if( z>0 )
        return(1);
    else if( z<0 )
        return(-1);
    else
        return(0);
}

void write_osg_head(FILE *F)
{
    fprintf(F,"Group {\n");
    fprintf(F,"  ClearNode {\n");
    fprintf(F,"  clearColor 0 0 0 1\n");
    fprintf(F,"  }\n");
    fprintf(F,"\n");
    fprintf(F,"Projection {\n");
    fprintf(F,"  DataVariance DYNAMIC\n");
    fprintf(F,"  nodeMask 0xffffffff\n");
    fprintf(F,"  cullingActive TRUE\n");
    fprintf(F,"  num_children 1\n");
    fprintf(F,"  MatrixTransform {\n");
    fprintf(F,"    DataVariance DYNAMIC\n");
    fprintf(F,"    nodeMask 0xffffffff\n");
    fprintf(F,"    cullingActive FALSE\n");
    fprintf(F,"    referenceFrame RELATIVE_TO_ABSOLUTE\n");
    fprintf(F,"    Matrix {\n");
    fprintf(F,"      1 0 0 0\n");
    fprintf(F,"      0 1 0 0\n");
    fprintf(F,"      0 0 1 0\n");
    fprintf(F,"      0 0 0 1\n");
    fprintf(F,"    }\n");
    fprintf(F,"    num_children 1\n");
    fprintf(F,"Geode {\n");
    fprintf(F,"  UniqueID Geode_0\n");
    fprintf(F,"  DataVariance DYNAMIC\n");
    fprintf(F,"  name \"hud_1\"\n");
    fprintf(F,"  cullingActive FALSE\n");
    fprintf(F,"  num_drawables 1\n");
    fprintf(F,"  Geometry {\n");
    fprintf(F,"    DataVariance DYNAMIC\n");

    if(!OSG_TEXTURED)
    {
        fprintf(F,"    useDisplayList FALSE\n");
        fprintf(F,"\n");
        fprintf(F,"\n");
    }
    else
    {
        fprintf(F,"    StateSet {\n");
        fprintf(F,"      UniqueID StateSet_1\n");
        fprintf(F,"      DataVariance STATIC\n");
        fprintf(F,"      rendering_hint DEFAULT_BIN\n");
        fprintf(F,"      renderBinMode INHERIT\n");
        fprintf(F,"      GL_CULL_FACE OFF\n");
        fprintf(F,"      GL_LIGHTING ON\n");
        fprintf(F,"      textureUnit 0 {\n");
        fprintf(F,"        GL_TEXTURE_2D ON\n");
        fprintf(F,"        Texture2D {\n");
        fprintf(F,"          DataVariance STATIC\n");
        fprintf(F,"          file \"target1024.jpg\"\n");
        fprintf(F,"          wrap_s REPEAT\n");
        fprintf(F,"          wrap_t REPEAT\n");
        fprintf(F,"          wrap_r CLAMP\n");
        fprintf(F,"          min_filter NEAREST_MIPMAP_LINEAR\n");
        fprintf(F,"          mag_filter LINEAR\n");
        fprintf(F,"          internalFormatMode USE_IMAGE_DATA_FORMAT\n");
        fprintf(F,"          subloadMode OFF\n");
        fprintf(F,"        }\n");
        fprintf(F,"        TexEnv {\n");
        fprintf(F,"          DataVariance STATIC\n");
        fprintf(F,"          mode DECAL\n");
        fprintf(F,"        }\n");
        fprintf(F,"      }\n");
        fprintf(F,"    }\n");
        fprintf(F,"    useDisplayList FALSE\n");
        fprintf(F,"\n");
        fprintf(F,"\n");
    }
}


void write_osg_tail(FILE *F)
{
    fprintf(F,"  }\n");
    fprintf(F,"}\n");
    fprintf(F,"\n");
    fprintf(F,"  Matrix {\n");
    fprintf(F,"    0.001953125 0 0 0\n");
    fprintf(F,"    0 0.0026041667 0 0\n");
    fprintf(F,"    0 0 -1 0\n");
    fprintf(F,"    -1 -1 -0 1\n");
    fprintf(F,"  }\n");
    fprintf(F,"}\n");
    fprintf(F,"\n");
    fprintf(F,"}\n");
    fprintf(F,"\n");
}


void save_mapping(int proj_res_y)
{
    int *index;
    float *point; // [x,y]
    FILE *F;
    int x,y,nbtri,nbpoint,j,i;
    int t1,t2,t3,t4,q1,q2,q3,q4;
    int k123,k134,z_pos_total,z_neg_total,z_good;
    char buf[200];

    index=(int *)malloc( g_img_size_x * g_img_size_y *sizeof(int));
    point=(float *)malloc( g_img_size_x * g_img_size_y *2*sizeof(int)); // [x,y]
    j=0;

    // find which points can participate at the end
    // here we use a different threshold
    for(i=0;i< g_img_size_x * g_img_size_y ;i++)
        index[i]=-1;

    for(y=0;y< g_img_size_y ;y+=TRIANGLE_SIZE)
    {
        for(x=0;x< g_img_size_x ;x+=TRIANGLE_SIZE)
        {
            i=y* g_img_size_x +x;
            if( xyvalid[i]<OUTPUT_VALIDITY_THRESHOLD )
                continue; // pixel not valid

            index[i]=j;

            //#warning SUBiX OVERIDES MOYSUBIX
            point[i*2+0]=(float)xcode[i]/(1<<SUBPIX);
            point[i*2+1]= ((float)proj_res_y - 1.0) - (float)ycode[i]/(1<<SUBPIX);
            j++;
        }
    }

    // before additional validation... distribute surface normals
    z_pos_total=z_neg_total=0;
    for(y=0;y< g_img_size_y -TRIANGLE_SIZE;y+=TRIANGLE_SIZE)
    {
        for(x=0;x< g_img_size_x -TRIANGLE_SIZE;x+=TRIANGLE_SIZE)
        {
            q1=y* g_img_size_x +x;
            q2=y* g_img_size_x +x+TRIANGLE_SIZE;
            q3=(y+TRIANGLE_SIZE)* g_img_size_x +x+TRIANGLE_SIZE;
            q4=(y+TRIANGLE_SIZE)* g_img_size_x +x;

            t1=index[q1];
            t2=index[q2];
            t3=index[q3];
            t4=index[q4];

            // first triangle
            if( t1>=0 && t2>=0 && t3>=0 )
            {
                k123=check_triangle(point[q1*2+0],point[q1*2+1],
                        point[q2*2+0],point[q2*2+1],
                        point[q3*2+0],point[q3*2+1]);
            }
            else
                k123=0;

            if( t1>=0 && t3>=0 && t4>=0 )
            {
                k134=check_triangle(point[q1*2+0],point[q1*2+1],
                        point[q3*2+0],point[q3*2+1],
                        point[q4*2+0],point[q4*2+1]);
            }
            else
                k134=0;

            if( k123<0 )
                z_neg_total++;
            if( k123>0 )
                z_pos_total++;
            if( k134<0 )
                z_neg_total++;
            if( k134>0 )
                z_pos_total++;
        }
    }

    if( z_pos_total >= z_neg_total )
        z_good=1;
    else
        z_good=-1;

    MPRINTF("STATS : z_pos=%d, z_neg=%d, z_good=-1\n",z_pos_total,z_neg_total);

    // additional validation... surface normals of the triangles...
    int nb_killed = 0;
    for(y=0;y< g_img_size_y -TRIANGLE_SIZE;y+=TRIANGLE_SIZE)
    {
        for(x=0;x< g_img_size_x -TRIANGLE_SIZE;x+=TRIANGLE_SIZE)
        {
            q1=y* g_img_size_x +x;
            q2=y* g_img_size_x +x+TRIANGLE_SIZE;
            q3=(y+TRIANGLE_SIZE)* g_img_size_x +x+TRIANGLE_SIZE;
            q4=(y+TRIANGLE_SIZE)* g_img_size_x +x;

            t1=index[q1];
            t2=index[q2];
            t3=index[q3];
            t4=index[q4];

            // first triangle
            if( t1>=0 && t2>=0 && t3>=0 )
            {
                k123=check_triangle(point[q1*2+0],point[q1*2+1],
                        point[q2*2+0],point[q2*2+1],
                        point[q3*2+0],point[q3*2+1]);
            }
            else
                k123=z_good;

            if( t1>=0 && t3>=0 && t4>=0 )
            {
                k134=check_triangle(point[q1*2+0],point[q1*2+1],
                        point[q3*2+0],point[q3*2+1],
                        point[q4*2+0],point[q4*2+1]);
            }
            else
                k134=z_good;

            if( k123!=z_good && k134!=z_good )
            {
                // 2 bad triangles!! Kill 4 points!
                index[q1]=-1;
                index[q2]=-1;
                index[q3]=-1;
                index[q4]=-1;
                //  MPRINTF("Kill reversed [%d,%d,%d,%d]\n",t1,t2,t3,t4);
                nb_killed+=4;
            }
            else if( k123!=z_good )
            {
                index[q2]=-1;
                //  MPRINTF("Kill reversed [%d]\n",t2);
                nb_killed +=1;
            }
            else if( k134!=z_good )
            {
                index[q4]=-1;
                // MPRINTF("Kill reversed [%d]\n",t4);
                nb_killed += 1;
            }
        }
    }

    MPRINTF("Number of deleted triangles: %d\n", nb_killed);

    // reorganize index because of the eliminated index...
    j=0;
    for(y=0;y< g_img_size_y ;y+=TRIANGLE_SIZE)
    {
        for(x=0;x< g_img_size_x ;x+=TRIANGLE_SIZE)
        {
            i=y* g_img_size_x +x;
            if( index[i]<0 )
                continue;
            index[i]=j;
            j++;
        }
    }

    // count triangles
    nbtri=0;
    for(y=0;y< g_img_size_y -TRIANGLE_SIZE;y+=TRIANGLE_SIZE)
    {
        for(x=0;x< g_img_size_x -TRIANGLE_SIZE;x+=TRIANGLE_SIZE)
        {
            t1=index[y* g_img_size_x +x];
            t2=index[y* g_img_size_x +x+TRIANGLE_SIZE];
            t3=index[(y+TRIANGLE_SIZE)* g_img_size_x +x+TRIANGLE_SIZE];
            t4=index[(y+TRIANGLE_SIZE)* g_img_size_x +x];

            if( t1>=0 && t2>=0 && t3>=0 )
                nbtri++;
            if( t1>=0 && t3>=0 && t4>=0 )
                nbtri++;
        }
    }

    sprintf(buf,"%sproj_%02d.osg",g_out_prefix,g_cam);
    F=fopen(buf,"w");
    if( F==NULL )
    {
        MPRINTF("Unable to open osg\n");
        LT_EXIT(0);
    }

    write_osg_head(F);

    fprintf(F,"Primitives 1\n");
    fprintf(F,"{\n");
    fprintf(F,"DrawElementsUShort TRIANGLES %d\n{\n",nbtri*3);
    for(y=0;y< g_img_size_y -TRIANGLE_SIZE;y+=TRIANGLE_SIZE)
    {
        for(x=0;x< g_img_size_x -TRIANGLE_SIZE;x+=TRIANGLE_SIZE)
        {
            t1=index[y* g_img_size_x +x];
            t2=index[y* g_img_size_x +x+TRIANGLE_SIZE];
            t3=index[(y+TRIANGLE_SIZE)* g_img_size_x +x+TRIANGLE_SIZE];
            t4=index[(y+TRIANGLE_SIZE)* g_img_size_x +x];

            if( t1>=0 && t2>=0 && t3>=0 )
            {
                fprintf(F,"%d %d %d\n",t1,t2,t3);
            }

            if( t1>=0 && t3>=0 && t4>=0 )
            {
                fprintf(F,"%d %d %d\n",t1,t3,t4);
            }
        }
    }
    fprintf(F,"}\n}\n");

    // find the number of points
    for(i=0,nbpoint=0;i< g_img_size_x * g_img_size_y ;i++)
    {
        if( index[i]<0 )
            continue;
        nbpoint++;
    }
    fprintf(F,"VertexArray Vec3Array %d\n{\n",nbpoint);

    for(i=0;i< g_img_size_x * g_img_size_y ;i++)
    {
        if( index[i]<0 )
            continue;

        fprintf(F,"%f %f 0\n",point[i*2+0],point[i*2+1]);
    }

    fprintf(F,"}\n");
    fprintf(F,"NormalBinding OVERALL\nNormalArray Vec3Array 1\n{\n0 0 1\n}\n");
    fprintf(F,"ColorBinding OVERALL\nColorArray Vec4Array 1\n{\n1 1 1 1\n}\n");
    fprintf(F,"TexCoordArray 0 UniqueID ltreconID Vec2Array %d\n{\n",nbpoint);

    for(i=0;i< g_img_size_x * g_img_size_y ;i++)
    {
        if( index[i]<0 )
            continue;

        fprintf(F,"%f %f\n",(float)(i% g_img_size_x )/( g_img_size_x -1.0),(float)(i/ g_img_size_x )/( g_img_size_y -1.0));
    }

    fprintf(F,"}\n");
    // New
    fprintf(F,"TexCoordArray 1 Use ltreconID\n");
    fprintf(F,"}\n");
    // New

    write_osg_tail(F);
    fclose(F);

    free(index);
    free(point);
}

void save_code ()
{
    char buf[400];

    sprintf(buf,"%sxcode_hi_new_%02d.png",g_out_prefix,g_cam);
    code_to_img(xcode, g_img_size_x, g_img_size_y, buf, 8, 3);

    sprintf(buf,"%sxcode_low_new_%02d.png",g_out_prefix,g_cam);
    code_to_img(xcode, g_img_size_x, g_img_size_y, buf, 8, 0);

    sprintf(buf,"%sxcode_lowest_new_%02d.png",g_out_prefix,g_cam);
    code_to_img(xcode, g_img_size_x, g_img_size_y, buf, 3, 0);


    sprintf(buf,"%sycode_hi_new_%02d.png",g_out_prefix,g_cam);
    code_to_img(ycode, g_img_size_x, g_img_size_y, buf, 8, 3);

    sprintf(buf,"%sycode_low_new_%02d.png",g_out_prefix,g_cam);
    code_to_img(ycode, g_img_size_x, g_img_size_y, buf, 8, 0);

    sprintf(buf,"%sycode_lowest_new_%02d.png",g_out_prefix,g_cam);
    code_to_img(ycode, g_img_size_x, g_img_size_y, buf, 3, 0);
}


typedef struct {
    int dx,dy;
    float weight;
} dxyinfo;

int cmpdxyinfo(dxyinfo *A,dxyinfo *B)
{
    if( A->weight < B->weight ) return(-1);
    if( A->weight > B->weight ) return(1);
    return(0);
}


void barycentric( double x1, double y1, double x2, double y2, double x3, double y3,
        double x,double y,
        double *a,double *b,double *c)
{
    double denom;
    denom=-(x2*y1) + x3*y1 + x1*y2 - x3*y2 - x1*y3 + x2*y3;
    if( denom==0.0 ) {
        *a = *b = *c = -1.0; // outside!
        return;
    }
    *a=-(x2*y - x3*y - x*y2 + x3*y2 + x*y3 - x2*y3)/denom;
    *b=-(-(x1*y) + x3*y + x*y1 - x3*y1 - x*y3 + x1*y3)/denom;
    *c=-(x1*y - x2*y - x*y1 + x2*y1 + x*y2 - x1*y2)/denom;
    if( *a>1.0 ) *a=1.0;
    if( *b>1.0 ) *b=1.0;
    if( *c>1.0 ) *c=1.0;
    return;
}

// retourne 0 si ok, -1 si pas un cercle
// calcule le centre (xc,yc) et rayon r d'un cercle passant par (x1,y1)(x2,y2)(x3,y3)
int circle(double x1, double y1, double x2, double y2, double x3, double y3,
        double *xc,double *yc,double *r)
{
    double denom;
    denom= 2*(x2*y1 - x3*y1 - x1*y2 + x3*y2 + x1*y3 - x2*y3);
    if( denom==0.0 ) return(-1);

    *xc = x3*x3*(-y1 + y2) + x2*x2*(y1 - y3) - (x1*x1 + (y1 - y2)*(y1 - y3))*(y2 - y3);
    *yc = x1*x1*(x2 - x3) + x2*x2*x3 + x3*(-y1*y1 + y2*y2) -
        x2*(x3*x3 - y1*y1 + y3*y3) +
        x1*(-x2*x2 + x3*x3 - y2*y2 + y3*y3);
    *r=(x1*x1 - 2*x1*x2 + x2*x2 + (y1 - y2)*(y1 - y2))*
        (x1*x1 - 2*x1*x3 + x3*x3 + (y1 - y3)*(y1 - y3))*
        (x2*x2 - 2*x2*x3 + x3*x3 + (y2 - y3)*(y2 - y3));

    *xc /= denom;
    *yc /= denom;
    *r = sqrt(*r/(denom*denom));

    return(0);
}

	int illegalx=0;
	int illegaly=0;


// fill triangle
// prend un triangle et marque les tableau imap_x,imap_y, et imap_dist
// Le triangle (x1,y1)(x2,y2)(x3,y3) est dans le uvmap
// Les valeurs u1,u2,u3 et v1,v2,v3 sont les coord camera a interpoler dans ce triangle
// les valeurs dont u,v,r
void scan_triangle(double x1,double y1,double x2,double y2,double x3,double y3,double u1,double u2,double u3,double v1,double v2,double v3,int imap_xs,int imap_ys,float *imap_u,float *imap_v,float *imap_r)
{
    double xmin,xmax,ymin,ymax;
    int x,y;
    double a,b,c,u,v,xc,yc,r;
    xmin=xmax=x1;
    if( x2<xmin ) xmin=x2;
    if( x2>xmax ) xmax=x2;
    if( x3<xmin ) xmin=x3;
    if( x3>xmax ) xmax=x3;
    ymin=ymax=y1;
    if( y2<ymin ) ymin=y2;
    if( y2>ymax ) ymax=y2;
    if( y3<ymin ) ymin=y3;
    if( y3>ymax ) ymax=y3;

    //k=check_triangle(x1,y1,x2,y2,x3,y3);
    circle(x1,y1,x2,y2,x3,y3,&xc,&yc,&r);

    if( r>MAXIMUM_R ) return; // pas un bon cercle!

    //LT_PRINTF("proj: (%f,%f)-(%f,%f)-(%f,%f) cam: (%f,%f)-(%f,%f)-(%f,%f) bb=(%f..%f,%f..%f) c=(%f,%f) r=%f\n",x1,y1,x2,y2,x3,y3,u1,v1,u2,v2,u3,v3,xmin,xmax,ymin,ymax,xc,yc,r);

	int iymin = (int)floor(ymin);
	int iymax = (int)ceil(ymax);
	int ixmin = (int)floor(xmin);
	int ixmax = (int)ceil(xmax);


    for(y=iymin;y<=iymax;y++) for(x=ixmin;x<=ixmax;x++) {
	// petite boucle pour donner une chance quand on passe en entier
	// en fait, c'est qu'un pixel est toujours +-0.5 autour de sa propre valeur
	int delta;
	for(delta=0;delta<5;delta++) {
		double dx,dy;
		switch(delta) {
		  case 0: dx=0;dy=0;break;
		  case 1: dx=-1;dy=0;break;
		  case 2: dx=1;dy=0;break;
		  case 3: dx=0;dy=-1;break;
		  case 4: dx=0;dy=1;break;
		}
		barycentric(x1,y1,x2,y2,x3,y3,(double)x+dx*0.5,(double)y+dy*0.1,&a,&b,&c);
		if( a>=0 && b>=0 && c>=0 ) break; // on a trouve! on est dans le triangle!
	}
	if( delta==5 ) continue; // rien trouve
	u=a*u1+b*u2+c*u3;
	v=a*v1+b*v2+c*v3;
	//LT_PRINTF("(%d,%d) : (%12.6f,%12.6f,%12.6f) u=%12.6f v=%12.6f\n",x,y,a,b,c,u,v);

	    if( x<0 || x>=imap_xs || y<0 || y>=imap_ys ) {
		if( x>illegalx ) { illegalx=x; /*printf("Illegal (%8d,%8d)\n",illegalx,illegaly);*/ }
		if( y>illegaly ) { illegaly=y; /*printf("Illegal (%8d,%8d)\n",illegalx,illegaly);*/ }
	    }

        int k;
        if( crop_active )
        {
            k=cropPixel(u,v);
        }else k=1;


        if( k ) {
	    if( x>=0 && x<imap_xs && y>=0 && y<imap_ys ) {
		    imap_u[y*imap_xs+x]=u;
		    imap_v[y*imap_xs+x]=v;
		    imap_r[y*imap_xs+x]=r;
	    }
	}
    }
}


void scan_all_triangles(int skip,int imap_xs,int imap_ys,float *imap_x,float *imap_y,float *imap_r,int *z_pos_total,int *z_neg_total, int proj_res_x, int proj_res_y)
{
    int x,y;
    int q1,q2,q3,q4;
    double q1x,q2x,q3x,q4x;
    double q1y,q2y,q3y,q4y;
    int k123,k134;
    double u1,u2,u3,u4,v1,v2,v3,v4;
    double scale_x,scale_y;
    int zsign;

    // si on veut que ca dessine des triangles, alors on suppose que zpos/zneg sont deja bon
    if( imap_x!=NULL ) {
        zsign = (*z_pos_total > *z_neg_total )?1:-1;
    }

    //find scaling values
    scale_x = (float)imap_xs / (float)proj_res_x;
    scale_y = (float)imap_ys / (float)proj_res_y;


//#ifdef SKIP
	// on scan les codes pour voir le range
	{
	int xmin,xmax,ymin,ymax,i;
	xmin=xmax=xcode[0];
	ymin=ymax=ycode[0];
	for(i=1;i<g_img_size_y*g_img_size_x;i++) {
		if( xcode[i]<xmin ) xmin=xcode[i];
		if( xcode[i]>xmax ) xmax=xcode[i];
		if( ycode[i]<ymin ) ymin=ycode[i];
		if( ycode[i]>ymax ) ymax=ycode[i];
	}
	LT_PRINTF("XCODE: %d .. %d\n",xmin,xmax);
	LT_PRINTF("YCODE: %d .. %d\n",ymin,ymax);
	// fabrique une image 16 bits
		{
			char buf[100];
			imgu *IX=NULL;
		    imguAllocate(&IX,g_img_size_x,g_img_size_y,3);
			for(i=0;i<g_img_size_y*g_img_size_x;i++) {
				IX->data[i*3+0]=xcode[i];
				IX->data[i*3+1]=ycode[i];
				IX->data[i*3+2]=0;
			}
		    sprintf(buf,"%sxcode_%02d.png",g_out_prefix, g_cam);
		    imguSave(IX,buf,FAST_COMPRESSION,SAVE_16_BITS);
		    imguFree(&IX);
		}
	}
//#endif

    *z_pos_total= *z_neg_total =0;

	// on scan (x,y) dans l'image de la camera
    for(y=0;y< g_img_size_y-skip;y+=skip) {
	//LT_PRINTF("cam Y=%d\n",y);
        for(x=0;x< g_img_size_x-skip;x+=skip) {
            q1=y* g_img_size_x +x;
            q2=y* g_img_size_x +x+skip;
            q3=(y+skip)* g_img_size_x +x+skip;
            q4=(y+skip)* g_img_size_x +x;

            q1x=xcode[q1] * scale_x;
            q2x=xcode[q2] * scale_x;
            q3x=xcode[q3] * scale_x;
            q4x=xcode[q4] * scale_x;

            q1y=ycode[q1] * scale_y;
            q2y=ycode[q2] * scale_y;
            q3y=ycode[q3] * scale_y;
            q4y=ycode[q4] * scale_y;

            if(xyvalid[q1]<INVERSE_MAP_VALIDITY_THRESHOLD) q1=-1;
            if(xyvalid[q2]<INVERSE_MAP_VALIDITY_THRESHOLD) q2=-1;
            if(xyvalid[q3]<INVERSE_MAP_VALIDITY_THRESHOLD) q3=-1;
            if(xyvalid[q4]<INVERSE_MAP_VALIDITY_THRESHOLD) q4=-1;

            // first triangle
            if( q1>=0 && q2>=0 && q3>=0 ) k123=check_triangle(q1x,q1y,q2x,q2y,q3x,q3y);
            else k123=0;

            if( q1>=0 && q3>=0 && q4>=0 ) k134=check_triangle(q1x,q1y,q3x,q3y,q4x,q4y);
            else k134=0;

            if( k123<0 ) *z_neg_total+=1;
            else if( k123>0 ) *z_pos_total+=1;
            if( k134<0 ) *z_neg_total+=1;
            else if( k134>0 ) *z_pos_total+=1;

            u1=x;
            u2=x+skip;
            u3=x+skip;
            u4=x;
#ifdef INVERSE_Y
            v1=(g_img_size_y - 1 - (y));
            v2=(g_img_size_y - 1 - (y));
            v3=(g_img_size_y - 1 - (y+skip));
            v4=(g_img_size_y - 1 - (y+skip));
#else
            v1=y;
            v2=y;
            v3=y+skip;
            v4=y+skip;
#endif

#ifdef FLIP_HORIZ
            u1=(g_img_size_x - 1 - u1);
            u2=(g_img_size_x - 1 - u2);
            u3=(g_img_size_x - 1 - u3);
            u4=(g_img_size_x - 1 - u4);
#endif
#ifdef FLIP_VERT
            v1=(g_img_size_y - 1 - v1);
            v2=(g_img_size_y - 1 - v2);
            v3=(g_img_size_y - 1 - v3);
            v4=(g_img_size_y - 1 - v4);
#endif


            if( q1>=0 && q2>=0 && q3>=0 && imap_x!=NULL && k123*zsign>0 )
		scan_triangle(q1x,q1y,q2x,q2y,q3x,q3y,u1,u2,u3,v1,v2,v3,imap_xs,imap_ys,imap_x,imap_y,imap_r);
            if( q1>=0 && q3>=0 && q4>=0 && imap_x!=NULL && k134*zsign>0 )
		 scan_triangle(q1x,q1y,q3x,q3y,q4x,q4y,u1,u3,u4,v1,v3,v4,imap_xs,imap_ys,imap_x,imap_y,imap_r);
        }
    }

    //LT_PRINTF("STATS : skip=%d, z_pos=%d, z_neg=%d\n",skip,*z_pos_total,*z_neg_total);
    return;
}





// This function make a inverse map of size imap_xs, imap_ys.
// xcode[i,j] and ycode[i,j] must contain a point x,y in the projector.
// We want to imap_x[..] and imap_y[..] to return i,j in camera image.
// scale_x and scale_y multiply the coordinates of the projector.
// chaque map contient 3 valeurs par pixel, les trois + proches...
void inverse_map(int imap_xs, int imap_ys, int proj_res_x, int proj_res_y)
{
    int i,x,y;
    float temp_code;
    float *imap_x,*imap_y; // [imap_xs*imap_ys], valeur de map inverse [y*xs+x]
    float *imap_r; // taille du triangle [y*xs+x]
    imgu *imap_final,*imap_final_cmap;
    imgu *temp_img; //temporary image for saving
    char buf[400],buf2[400]; //text buffer
    char cmd[400];
    int zpos[20],zneg[20],zsign[20];
    int skip;

    temp_img=NULL;
    imap_final=NULL;
    imap_final_cmap=NULL;

    LT_PRINTF("InverseMap... imgsize=(%d,%d) imap (%d,%d) for proj (%d,%d)\n",g_img_size_x,g_img_size_y,imap_xs,imap_ys,proj_res_x,proj_res_y);


    /// allocate memory
    imap_x=(float *)malloc(imap_xs*imap_ys*sizeof(float));
    imap_y=(float *)malloc(imap_xs*imap_ys*sizeof(float));
    imap_r=(float *)malloc(imap_xs*imap_ys*sizeof(float));

    // ???????????? pourquoi maintenant?
    imguAllocateComplex(&imap_final,imap_xs,imap_ys,1);

    // init : rayon trop grand
    for(i=0;i<imap_xs*imap_ys;i++) { imap_r[i]=99999999.0; }


	// ON UTILISE 2 ici A CAUSE DE forced skip=2 un peu plus bas (!!!!!!!!!!)
    // imap_xyr can be set to null for statistics only
    //for( skip=1;skip<10;skip++) {
    for( skip=2;skip<3;skip++) {
        scan_all_triangles(skip,imap_xs,imap_ys,NULL,NULL,NULL,zpos+skip,zneg+skip,proj_res_x,proj_res_y);
        zsign[skip] = (zpos[skip]>zneg[skip])?1:-1;
	//LT_PRINTF("skip=%d: pos=%d neg=%d\n",skip,zpos[skip],zneg[skip]);
    }

#ifdef ELIMINE
    // output stats
    for( skip=1;skip<10;skip++) {
        LT_PRINTF("skip = %2d , pos=%6d  neg=%6d : %12.2f%%  %12.2f%%\n",skip,
                zpos[skip],zneg[skip],
                (float)zneg[skip]/zpos[skip]*100.0,
                (float)zpos[skip]/zneg[skip]*100.0);
    }
    // select best
    // On commence a 2, mais bon...
    for(skip=2;skip<9;skip++) {
        if( zpos[skip]>zneg[skip] && (float)zneg[skip]/zpos[skip]<0.21 ) break;
        if( zpos[skip]<zneg[skip] && (float)zpos[skip]/zneg[skip]<0.21 ) break;
    }
    //// a cause des discontinuites... les stats ne sont pas fiables...
#endif
    skip=2;
    LT_PRINTF("forced: skip is %d\n",skip);

    scan_all_triangles(skip,imap_xs,imap_ys,imap_x,imap_y,imap_r,zpos+skip,zneg+skip,proj_res_x,proj_res_y);

#ifdef SKIP
    //go through each pixel of the camera image and vote for distances
    for(y=0;y<g_img_size_y;y++) {
        for(x=0;x<g_img_size_x;x++) {
            // camera says it's invalid
            if(xyvalid[y*g_img_size_x+x]<INVERSE_MAP_VALIDITY_THRESHOLD) continue;

            //LT_PRINTF("vote (%d,%d) valid=%d\n",x,y,xyvalid[y*g_img_size_x+x]);

            // read xcode and ycode, scale and round them
            imap_xcode=(int)(xcode[y * g_img_size_x + x] * scale_x +0.5);
            imap_ycode=(int)(ycode[y * g_img_size_x + x] * scale_y +0.5);

            //LT_PRINTF("(%d,%d)proj\n",imap_xcode,imap_ycode);

            // outside the projector
            if( imap_xcode<0 || imap_xcode>=imap_xs || imap_ycode<0 || imap_ycode>=imap_ys ) continue;

            // save the value as a '0' distance
            //LT_PRINTF("voting at (%d,%d)proj = (%d,%d)cam\n",imap_xcode,imap_ycode,x,y);
            imap_r[(imap_ycode*imap_xs+imap_xcode)] = 1.0;
            imap_x[(imap_ycode*imap_xs+imap_xcode)] = x;
            imap_y[(imap_ycode*imap_xs+imap_xcode)] =
#ifdef INVERSE_Y
                (g_img_size_y - 1 - y);
#else
            y;
#endif
        }
    }
#endif

    LT_PRINTF("selecting final code...\n");

#define OUT_OF_CAM -1.0
    // get imap_x and imap_y in texture mapping format (0..1)
    // and put it in imap_x_final and imap_y_final
    for(y=0;y<imap_ys;y++)
    {
        for(x=0;x<imap_xs;x++)
        {
            int adr = y * imap_xs + x; //address
            int adr_inv = (imap_ys - 1 - y) * imap_xs + x; //inverse-y address

            // prends seulement le premier pour l'instant
            if( imap_r[adr]>999.0 )
            {
                temp_code=OUT_OF_CAM;
            }
            else
            {
                temp_code = imap_x[adr] / g_img_size_x;
                if( temp_code<0 )
                    temp_code=0.0;
                if( temp_code>1 )
                    temp_code=1.0;
            }
#ifdef INVERSE_Y
            imap_final->complex[adr_inv][0]=temp_code;
#else
            imap_final->complex[adr][0]=temp_code;
#endif

            if( imap_r[adr]>999.0 )
            {
                temp_code=OUT_OF_CAM;
            }
            else
            {
                temp_code = imap_y[adr] / g_img_size_y;
                if( temp_code<0 )
                    temp_code=0.0;
                if( temp_code>1 )
                    temp_code=1.0;
            }
#ifdef INVERSE_Y
            imap_final->complex[adr_inv][1]=temp_code;
#else
            imap_final->complex[adr][1]=temp_code;
#endif
        }
    }

    LT_PRINTF("Creating images...\n");

    // save imap_x_final and imap_y_final in separate images files
    imguAllocate(&temp_img,imap_xs,imap_ys,1);
    for(i=0;i<imap_xs*imap_ys;i++) {
        if(imap_final->complex[i][0] == OUT_OF_CAM)
            temp_img->data[i]=(int)(0.5*255.0+0.5);
        else
            temp_img->data[i]= imap_final->complex[i][0]*255;
    }
    sprintf(buf,"%simapX_%02d.png",g_out_prefix, g_cam);
    imguSave(temp_img,buf,FAST_COMPRESSION,SAVE_8_BITS_LOW);
    MPRINTF ("Saved %s\n", buf);
    for(i=0;i<imap_xs*imap_ys;i++)
        if(imap_final->complex[i][1] == OUT_OF_CAM)
            temp_img->data[i]=(int)(0.5*255.0+0.5);
        else
            temp_img->data[i]= imap_final->complex[i][1]*255;
    sprintf(buf,"%simapY_%02d.png",g_out_prefix, g_cam);
    imguSave(temp_img,buf,FAST_COMPRESSION,SAVE_8_BITS_LOW);
    MPRINTF ("Saved %s\n", buf);
    imguFree(&temp_img);

    {
        FILE *F;
        int adr;
        // save imap_x_final and imap_y_final in the same list file
        sprintf(buf,"%simapXY_%02d.lut.png",g_out_prefix, g_cam);
        sprintf(buf2,"%simapXY_%02d-copy.lut.png",g_out_prefix, g_cam);
        imguConvertFromComplexUV(&imap_final_cmap,imap_final);
        imguSave(imap_final_cmap,buf,FAST_COMPRESSION,SAVE_16_BITS);
        sprintf(cmd,"cp %s %s\n",buf,buf2);
        system(cmd);
    }

    LT_PRINTF("done\n");
}


typedef struct {
	int i;  // index dans l'image
	int r;  // le range
} pointinfo;

int cmpPI(pointinfo *A,pointinfo *B)
{
	if( A->r<B->r ) return(1);
	if( A->r>B->r ) return(-1);
	return(0);
}

// nouveau!
//
// preprocess les patterns en fonction de l'eclairage ambient
//
// On a p patterns, chacun avec son negatif p'
// Dans un pattern, on a le point i
//
// I(p;i) = s(i) B + A(p)             (ou N)
// I(p';i) = s(i) N + A(p')           (ou B)
// ou B et N sont les couleurs vraies du blan et noir (constante fois les couleurs projetees)
// s(i) = reflectance en i
// A(p) = ambient pattern p
//
// Soit I(p;i) - I(p';i) = D(p;i) = s(i) ( B-N ) + (A(p)-A(p')) 
//      ou  = D(p;i)'   = s(i) ( N-B ) + (A(p)-A(p'))
// Soi un deuxieme point j, avec D(p;j) et D(p;j)'
//
// Si on suppose que les points i et j on la meme reflectance:
//
// D(p;i) + D(p;j) = 2 (A(p)-A(p'))
// D'(p;i) + D'(p;j) = 2 (A(p)-A(p'))
// D(p;i) + D'(p;j) = 2 s(i) (B-N) + 2 (A(p)-A(p'))
// D'(p;i) + D(p;j) = 2 s(i) (B-N) + 2 (A(p)-A(p'))
//
// On vote pour plein de i et j et on regarde ce que ca donne...
//
//
void preprocess_ambient(imgu **Ip,int nb)
{
imgu *Ia=NULL; // mask for selecting pixels
imgu *Imax=NULL; // maximum image of patterns
imgu *Imin=NULL; // minimum image of patterns
int x,y;
int ambient[nb];
int i,j,k,h,pos,neg,p;
int xs,ys;
int nbpi;
pointinfo *pi;
	xs=Ip[0]->xs;
	ys=Ip[0]->ys;
	for(i=0;i<nb;i++) printf("pat[%d] had pos %d and inv %d\n",i,pat[i].pos,pat[i].neg);


	pi=(pointinfo *)malloc(xs*ys*sizeof(pointinfo));
	nbpi=0;



	imguAllocate(&Ia,Ip[0]->xs,Ip[0]->ys,1);
	imguAllocate(&Imin,Ip[0]->xs,Ip[0]->ys,1);
	imguAllocate(&Imax,Ip[0]->xs,Ip[0]->ys,1);

	//
	// MASK
	//
	for(y=0;y<Ia->ys;y++) for(x=0;x<Ia->xs;x++) {
		if( crop_active ) {
			PIXEL(Ia,x,y,0)=cropPixel(x,y)?65535:0;
		}else	PIXEL(Ia,x,y,0)=65535;
        }
	imguSave(Ia,"/home/roys/lighttwist/scan/out/seb_mask.png",1,SAVE_16_BITS);

	//
	// tmin,tmax
	//
	for(i=0;i<Ia->xs*Ia->ys;i++) {
		if( Ia->data[i]==0 ) {
			Imin->data[i]=Imax->data[i]=0;
			for(j=0;j<nb;j++) Ip[j]->data[i]=0; // outside!
		}else{
			Imin->data[i]=Ip[0]->data[i];
			for(j=1;j<nb;j++) {
				if( Imin->data[i] > Ip[j]->data[i] ) Imin->data[i]=Ip[j]->data[i];
				if( Imax->data[i] < Ip[j]->data[i] ) Imax->data[i]=Ip[j]->data[i];
			}
			// normalize
			/*
			for(j=0;j<nb;j++) {
				Ip[j]->data[i]=(Ip[j]->data[i]*255)/Imax->data[i]; // normalize sur le max
			}
			*/
		}
	}

	//
	// Choix des 5% plus grand Trange
	//
	{
		nbpi=0;
		for(i=0;i<xs*ys;i++) {
			if( Ia->data[i]==0 ) continue; // pas dans l'image
			pi[nbpi].i=i;
			pi[nbpi].r=Imax->data[i] - Imin->data[i];
			nbpi++;
		}
		// sort les pi
		qsort(pi,nbpi,sizeof(pointinfo),(void *)cmpPI);
		//for(i=0;i<nbpi;i++) printf("%8d: %d\n",i,pi[i].r);

	}


	//
	// Statistique
	//
	int nbselect = (PERCENT_HIGHEST_TRANGE*nbpi)/100; // on garde 10 pour cent, disons
	printf("nbselect=%d\n",nbselect);
	for(p=0;p<nb;p++) {
		printf("pattern p=%d\n",p);
		int di,dj,v;
		pos=pat[p].pos;
		neg=pat[p].neg;
		int H[511]; // histo (-255..255) | [pos]>[neg]
		int G[511]; // histo (-255..255) | [pos]<[neg]
		int Hn[511];
		int Gn[511];
		for(h=0;h<511;h++) H[h]=G[h]=0;
		for(j=0;j<nbselect;j++) {
			i=pi[j].i;
			di=Ip[pos]->data[i] - Ip[neg]->data[i];
			if( di>0 ) H[di+255]++;
			if( di<0 ) G[di+255]++;
		}
		// rolling average
		int Hmax=0;
		int Gmax=0;
		for(j=0;j<511;j++) {
			int sum,nn,max;
			sum=nn=0;
			for(i=-10;i<=10;i++) if( i+j>=0 && i+j<511 ) { sum+=H[i+j];nn++; }
			if( nn==0 ) nn=1;
			Hn[j]=sum/nn;
			if( Hn[j]>Hmax ) Hmax=Hn[j];
			sum=nn=0;
			for(i=-10;i<=10;i++) if( i+j>=0 && i+j<511 ) { sum+=G[i+j];nn++; }
			if( nn==0 ) nn=1;
			Gn[j]=sum/nn;
			if( Gn[j]>Gmax ) Gmax=Gn[j];
		}
		if( Hmax==0 ) Hmax=1;
		if( Gmax==0 ) Gmax=1;
		for(i=0;i<511;i++) Hn[i]=(Hn[i]*1000)/Hmax;
		for(i=0;i<511;i++) Gn[i]=(Gn[i]*1000)/Gmax;
		/***
		for(i=0;i<xs*ys;i++) {
			if( Ia->data[i]==0 ) continue; // pas dans l'image
			if( Imax->data[i] - Imin->data[i] < 135 ) continue; // skip fixed obj
			di=Ip[pos]->data[i] - Ip[neg]->data[i];
			if( di>0 ) H[di+255]++;
			if( di<0 ) G[di+255]++;
		}
		***/
		//for(h=0;h<511;h++) printf("%d %d\n",h-255,Hn[h]);
		//for(h=0;h<511;h++) printf("%d %d\n",h-255,Gn[h]);
		// MIX H et G pour avoir un ajustement
		int Z[511];
		for(i=0;i<511;i++) Z[i]=0;
		for(i=0;i<511;i++) for(j=0;j<511;j++) Z[(int)(floor(((i-255)+(j-255))/2.0))+255]+=(Hn[i]*Gn[j])/1000;
		// trouve le maximum du Z, c'est l'ambient
		int Zmax=0;
		int ZmaxPos=-1;
		for(i=0;i<511;i++) if( Z[i]>Zmax ) { Zmax=Z[i];ZmaxPos=i-255; }
		fprintf(stderr,"pattern %d : delta ambient = %d\n",p,ZmaxPos);
		//for(i=0;i<511;i++) Z[i]=(Z[i]*1000)/Zmax;
		//for(h=0;h<511;h++) printf("%d %d\n",h-255,Z[h]);
	
		ambient[p]=ZmaxPos;
	}

	// ajuste
	for(p=0;p<nb;p++) {
		pos=pat[p].pos;
		neg=pat[p].neg;
		for(i=0;i<xs*ys;i++) {
			int a,b;
			a=Ip[pos]->data[i]-ambient[p]/2;
			b=Ip[neg]->data[i]+ambient[p]/2;
			while( a<0 ) { a++;b--; }
			while( a>255 ) { a--;b++; }
			while( b<0 ) { b++;a--; }
			while( b>255 ) { b--;a++; }
			if( a<0 || a>255 || b<0 || b>255 ) {
				fprintf(stderr,"ERR\n");
			}else{
				Ip[pos]->data[i]=a;
				Ip[neg]->data[i]=b;
			}
		}
	}


	// save patterns
	for(j=0;j<nb;j++) {
		char buf[100];
		sprintf(buf,"/home/roys/lighttwist/scan/out/seb_%02d.png",pat[j].pos);
		imguSave(Ip[pat[j].pos],buf,1,SAVE_8_BITS_LOW);
		sprintf(buf,"/home/roys/lighttwist/scan/out/seb_%02d.png",pat[j].neg);
		imguSave(Ip[pat[j].neg],buf,1,SAVE_8_BITS_LOW);
	}
	//imguSave(Imin,"/home/roys/lighttwist/scan/out/seb_min.png",1,SAVE_8_BITS_LOW);
	//imguSave(Imax,"/home/roys/lighttwist/scan/out/seb_max.png",1,SAVE_8_BITS_LOW);

	imguFree(&Ia);
	imguFree(&Imin);
	imguFree(&Imax);
}


int main_ltrecon(imgu **Tselect_param, imgu *Trange_param, int img_size_x, int img_size_y, char *out_prefix, int type, float mrf_beta_param, int cam, int imap_xs, int imap_ys, int smooth_ws, int confidence_min, int range_min, char *target_path, char *crop_filename, int proj_res_x, int proj_res_y,int nb_pattern)
{
    int i,k,n;
    char buf[200];
    unsigned long mx,my; // used to setup pattern information
    char type_prefix[400];  // Prefix for the type of reconstruction
    
    nbbits_x=getnbbits(proj_res_x);
    nbbits_y=getnbbits(proj_res_y);

    pat=(pattern *)(malloc(sizeof(pattern)*nb_pattern));


    // init le crop
    crop_active = crop_filename[0]?1:0;
    if( crop_active ) {
        cropLoadUVMap(crop_filename);
    }


    // fill global variables
    Tselect = Tselect_param;
    Trange = Trange_param;
    g_img_size_x = img_size_x;
    g_img_size_y = img_size_y;
    g_out_prefix = out_prefix;
    g_type = type;
    g_cam = cam;
    if(mrf_beta_param != INVALID)
        g_mrf_beta = mrf_beta_param;
    else
        g_mrf_beta = MRF_BETA;
    g_range_min = range_min;

    init_gray_tables (nbbits_x+SUBPIX,nbbits_y+SUBPIX);

    // setup pattern information (seulement la moitie des patterns)
    for(n=0;n<nbbits_x+nbbits_y;n++)
    {
        if( n<nbbits_x )
        {
            //mx=1<<(nbbits_x-1-n);
            //mx=1<<(n);
            //mx=(getpowerof2(nbbits_x)/2>>n);
            mx=1<<(nbbits_x-1-n);
            my=0;
        }
        else if( n<nbbits_x+nbbits_y )
        {
            mx=0;
	        //my=1<<(nbbits_y+nbbits_x-1-n);
  	        //my=1<<(n-nbbits_y);
            //my=(getpowerof2(nbbits_y)/2>>(n-nbbits_x));
            my=1<<(nbbits_y+nbbits_x-1-n);
        }

        pat[n].mx=mx;
        pat[n].my=my;
        pat[n].pos=n;
        pat[n].neg=n+nbbits_x+nbbits_y;
	LT_PRINTF("pattern[%2d] : mx=%2d my=%2d pos=%2d neg=%2d\n",n,pat[n].mx,pat[n].my,pat[n].pos,pat[n].neg);
    }

    // nouveau!
    //preprocess_ambient(Tselect_param,nbbits_x+nbbits_y);

    switch(g_type)
    {
        case ORIG:
            LT_PRINTF("OK1\n");
            sprintf(type_prefix, "orig");
            LT_PRINTF("OK2\n");
            recover_xy(confidence_min,nb_pattern);
            LT_PRINTF("OK3\n");
            LT_PRINTF("BSI\n");
            LT_PRINTF("OK5\n");
            LT_PRINTF("OK6\n");
            LT_PRINTF("BSI DONE\n");
            LT_PRINTF("OK7\n");
            kill_gray();
            LT_PRINTF("OK8\n");
            inverse_map(imap_xs, imap_ys, proj_res_x, proj_res_y);
            LT_PRINTF("OK9\n");
            save_mapping(proj_res_y);
            LT_PRINTF("OK10\n");
            save_code();
            LT_PRINTF("OK11\n");
            break;

        case SMOOTH:
            sprintf(type_prefix, "smooth");
            recover_xy(confidence_min,nb_pattern);
            kill_gray();
            mean(smooth_ws);
            inverse_map(imap_xs, imap_ys, proj_res_x, proj_res_y);
            save_mapping(proj_res_y);
            save_code();
            break;

        case MARKOV_SIMPLE:
        case MARKOV_JP:
            sprintf (type_prefix, "mrfIS");
            recover_xy(confidence_min,nb_pattern);

            NB_MAX_ITER=10;
            {
                int nb_iter = NB_MAX_ITER; //nb_iter without improvement
                MrfI_init ();
                while (nb_iter > 0)
                {
                    int b = MrfI_fix_xy((PROJ_CODE<<SUBPIX)-1);
                    if (b > 0)
                        nb_iter = NB_MAX_ITER;
                    else
                        nb_iter--;
                }

                //put back the best in the state of the code
                int i;
                for (i = 0; i < g_img_size_x*g_img_size_y; i++)
                {
                    xcode[i] = x_bestcode[i];
                    ycode[i] = y_bestcode[i];
                }
            }

            kill_gray();

            inverse_map(imap_xs, imap_ys, proj_res_x, proj_res_y);
            save_mapping(proj_res_y);
            save_code();
            break;

        case MARKOV_CONT:
            sprintf (type_prefix, "mrfIC");
            recover_xy(confidence_min,nb_pattern);

            NB_MAX_ITER=7;
            {
                MrfI_init ();
                int nb_iter = NB_MAX_ITER; //nb_iter without improvement
                while (nb_iter > 0)
                {
                    int b = MrfI_fix_xy((PROJ_CODE<<SUBPIX)-1);
                    if (b > 0)
                        nb_iter = NB_MAX_ITER;
                    else
                        nb_iter--;

                    if (g_nb_site_changed == 0)
                        break;
                }

                //put back the best in the state of the code
                int i;
                for (i = 0; i < g_img_size_x*g_img_size_y; i++)
                {
                    xcode[i] = x_bestcode[i];
                    ycode[i] = y_bestcode[i];
                }
            }
            kill_gray();

            inverse_map(imap_xs, imap_ys, proj_res_x, proj_res_y);
            save_code();
            save_mapping(proj_res_y);
            break;
    }


    int x,y,xx,yy;
    imgu *Target,*ID;
    char target_filename[200];

    Target=NULL;
    ID=NULL;

    free(xcode);
    free(ycode);
    free(xconf);
    free(yconf);
    free(xyvalid);

    free(pat);

    // ** done **
    sprintf(buf,"touch %sdone",g_out_prefix);
    system(buf);

    return(0);
}


